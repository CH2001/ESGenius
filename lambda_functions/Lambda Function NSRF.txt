import json
import base64
import boto3
import time
import os
import logging

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients outside the handler for reuse
# This is a best practice for performance in AWS Lambda
s3_client = boto3.client('s3')
textract_client = boto3.client('textract')
bedrock_runtime = boto3.client('bedrock-runtime')
dynamodb_client = boto3.client('dynamodb')
# NEW: Use the Bedrock Agent Runtime client to query the knowledge base
bedrock_agent_runtime = boto3.client('bedrock-agent-runtime')

# --- CONFIGURATION ---
# Get configuration from environment variables for flexibility
# You MUST set these in your Lambda function's configuration
S3_BUCKET_NAME = os.environ.get('S3_BUCKET_NAME')
BEDROCK_MODEL_ID = os.environ.get('BEDROCK_MODEL_ID', 'us.anthropic.claude-sonnet-4-20250514-v1:0')
DYNAMODB_TABLE_NAME = os.environ.get('DYNAMODB_TABLE_NAME')
# UPDATED: Use the Bedrock Knowledge Base ID instead of Kendra Index ID
BEDROCK_KB_ID = os.environ.get('BEDROCK_KB_ID')

def lambda_handler(event, context):
    """
    Main handler for the Lambda function.
    Triggered by API Gateway. Expects a base64-encoded PDF file in the request body.
    """
    logger.info("NSRF RAG analysis function with Bedrock KB triggered.")

    # --- 1. Validate Input and Decode PDF ---
    if not all([S3_BUCKET_NAME, DYNAMODB_TABLE_NAME, BEDROCK_KB_ID]): # UPDATED: Check for Bedrock KB ID
        logger.error("Required environment variables are not set. Check S3_BUCKET_NAME, DYNAMODB_TABLE_NAME, and BEDROCK_KB_ID.")
        return create_api_response(500, {"error": "Server configuration error."})

    try:
        body = json.loads(event.get('body', '{}'))
        file_content_base64 = body.get('fileContent')
        if not file_content_base64:
            return create_api_response(400, {"error": "fileContent not found in request body."})
        pdf_bytes = base64.b64decode(file_content_base64)
        logger.info("Successfully decoded base64 PDF content.")
    except (json.JSONDecodeError, TypeError, ValueError) as e:
        logger.error(f"Error decoding request body or base64 content: {e}")
        return create_api_response(400, {"error": "Invalid request format."})

    # --- 2. Upload PDF to S3 for Textract ---
    s3_key = f"temp-uploads/{context.aws_request_id}.pdf"
    try:
        s3_client.put_object(Bucket=S3_BUCKET_NAME, Key=s3_key, Body=pdf_bytes)
        logger.info(f"PDF temporarily uploaded to S3 at s3://{S3_BUCKET_NAME}/{s3_key}")
    except Exception as e:
        logger.error(f"Failed to upload to S3: {e}")
        return create_api_response(500, {"error": "Could not process file upload."})

    # --- 3. Extract Text with Textract ---
    try:
        extracted_text = start_textract_job(s3_key)
        if not extracted_text:
             return create_api_response(500, {"error": "Text extraction failed."})
        logger.info(f"Text extraction successful. Total characters: {len(extracted_text)}")
    except Exception as e:
        logger.error(f"An error occurred during text extraction: {e}")
        return create_api_response(500, {"error": "Failed to extract text from PDF."})
    finally:
        # Cleanup S3 file
        try:
            s3_client.delete_object(Bucket=S3_BUCKET_NAME, Key=s3_key)
            logger.info(f"Cleaned up temporary S3 object: {s3_key}")
        except Exception as e:
            logger.warning(f"Failed to clean up S3 object {s3_key}: {e}")

    # --- 4. RAG - Retrieve Context from Bedrock Knowledge Base ---
    try:
        # Use the first part of the extracted text as the query for the knowledge base
        query_text = extracted_text[:500]
        retrieved_context = retrieve_from_bedrock_kb(query_text)
        logger.info(f"Retrieved {len(retrieved_context)} characters of context from Bedrock KB.")
    except Exception as e:
        logger.error(f"Error retrieving context from Bedrock KB: {e}")
        return create_api_response(500, {"error": "Failed to query knowledge base."})

    # --- 5. Analyze Text with Bedrock (Now with RAG context) ---
    try:
        analysis_prompt = create_bedrock_prompt(extracted_text, retrieved_context)
        
        bedrock_payload = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "messages": [{"role": "user", "content": analysis_prompt}]
        }
        response = bedrock_runtime.invoke_model(body=json.dumps(bedrock_payload), modelId=BEDROCK_MODEL_ID)
        response_body = json.loads(response['body'].read())
        analysis_result_text = response_body['content'][0]['text']
        analysis_result_json = json.loads(analysis_result_text)
        logger.info("Successfully received and parsed analysis from Bedrock.")
    except Exception as e:
        logger.error(f"Error calling Bedrock or parsing its response: {e}")
        return create_api_response(500, {"error": "AI analysis failed."})

    # --- 6. Save to DynamoDB ---
    try:
        item_id = context.aws_request_id
        save_to_dynamodb(item_id, analysis_result_json)
        logger.info(f"Successfully saved analysis to DynamoDB with ID: {item_id}")
    except Exception as e:
        logger.error(f"Failed to save analysis to DynamoDB: {e}")

    # --- 7. Return Result ---
    return create_api_response(200, analysis_result_json)

# --- NEW RAG FUNCTION for Bedrock Knowledge Base ---
def retrieve_from_bedrock_kb(query_text):
    """Queries the Bedrock Knowledge Base and returns the most relevant context."""
    response = bedrock_agent_runtime.retrieve(
        knowledgeBaseId=BEDROCK_KB_ID,
        retrievalQuery={
            'text': query_text
        },
        retrievalConfiguration={
            'vectorSearchConfiguration': {
                'numberOfResults': 10  
            }
        }
    )
    
    context = ""
    # The response structure from Bedrock KB is different from Kendra
    for result in response.get('retrievalResults', []):
        context += result['content']['text'] + "\n\n"
        
    return context


def create_bedrock_prompt(extracted_text, retrieved_context):
    """Creates the detailed prompt for the Bedrock LLM using retrieved context."""
    # This function's logic remains the same, it just gets better context now.
    prompt = f"""
    You are an expert AI assistant specializing in sustainability reporting and compliance with the Malaysian National Sustainability Reporting Framework (NSRF).
    Your task is to analyze the following extracted text from a corporate sustainability report. Use the provided "NSRF Context" which contains the most relevant rules and guidelines from our knowledge base to perform your analysis.
    
    **NSRF Context from Knowledge Base:**
    ---
    {retrieved_context}
    ---
    
    **Extracted Report Text to Analyze:**
    ---
    {extracted_text[:]}
    ---
    
    Please provide a structured analysis in a single, valid JSON object based on the provided context and report text. Do not include any text outside of the JSON object.
    The JSON object should have a single root key called "nsrfAnalysis".
    The value of "nsrfAnalysis" should be an object with two keys: "strengths" and "weaknesses".
    
    - "strengths": A list of strings, where each string is a point where the report successfully addresses a specific rule from the provided NSRF Context.
    - "weaknesses": A list of objects, where each object represents a gap or area for improvement. Each object must have three keys:
        - "finding": A concise description of the weakness or missing information.
        - "nsrfPrinciple": The specific NSRF principle it relates to (e.g., "Governance", "Metrics and Targets").
        - "recommendation": A clear, actionable suggestion on how to improve the report to meet the NSRF requirement, referencing the provided context.

    Analyze the provided text and generate the JSON output.
    """
    return prompt

def start_textract_job(s3_key):
    response = textract_client.start_document_text_detection(DocumentLocation={'S3Object': {'Bucket': S3_BUCKET_NAME, 'Name': s3_key}})
    job_id = response['JobId']
    logger.info(f"Started Textract job with ID: {job_id}")
    waiter = textract_client.get_waiter('document_text_detection_completed')
    waiter.wait(JobId=job_id, WaiterConfig={'Delay': 5, 'MaxAttempts': 60})
    pages, next_token = [], None
    while True:
        params = {'JobId': job_id}
        if next_token: params['NextToken'] = next_token
        result = textract_client.get_document_text_detection(**params)
        pages.append(result)
        next_token = result.get('NextToken')
        if not next_token: break
    full_text = ""
    for page in pages:
        for item in page['Blocks']:
            if item['BlockType'] == 'LINE': full_text += item['Text'] + '\n'
    return full_text

def save_to_dynamodb(item_id, analysis_data):
    timestamp = str(time.time())
    item = { 'analysisId': {'S': item_id}, 'createdAt': {'S': timestamp}, 'analysisResult': {'S': json.dumps(analysis_data)} }
    dynamodb_client.put_item(TableName=DYNAMODB_TABLE_NAME, Item=item)

def create_api_response(status_code, body):
    return {
        "statusCode": status_code,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Headers": "Content-Type",
            "Access-Control-Allow-Methods": "POST, OPTIONS"
        },
        "body": json.dumps(body)
    }


